#!/usr/bin/env python3
#
# netcdf_to_vtk
#
# Converts a netCDF file into a VTK file. The format of the VTK file
# follows the 'legacy format' and will be a structured grid. In case
# the input file consists of multiple time steps, every time step is
# stored as a separate VTK file, with an appropriate suffix.
#
# This converter only handles scalar fields. It looks up the _first_
# variable that is _neither_ longitude _nor_ latitude _nor_ time. If
# said variable is not scalar, the behaviour of the converter is not
# defined.

import math
import netCDF4
import os
import sys

#
# Read data set
#

filename = sys.argv[1]
dataSet  = netCDF4.Dataset(filename, mode='r')

lons  = dataSet.variables['lon'][:]
lats  = dataSet.variables['lat'][:]
times = dataSet.variables['time'][:]

variables = dataSet.variables
variable  = None

for v in variables:
  if not variable and v not in ["lon", "lat", "time"]:
    variable = v

# Figures out at which indices the individual dimensions are stored in
# order to simplify accessing the variable array later on.
dimensions = dataSet.variables[variable].dimensions
vt         = dimensions.index("time")
vx         = dimensions.index("lon")
vy         = dimensions.index("lat")

#
# Generate header & pre-process data
#

nx = len(lons)
ny = len(lats)
nt = len(times)
td = math.ceil(math.log(nt, 10))

header = ("# vtk DataFile Version 3.0\n"
          "Generated by netcdf_to_vtk\n"
          "ASCII\n"
          "DATASET STRUCTURED_GRID\n"
          "DIMENSIONS %d %d %d\n"
          "POINTS %d double") % (nx,ny,1,nx*ny)

scalars = ("POINT_DATA %d\n"
           "SCALARS %s double 1\n"
           "LOOKUP_TABLE default") % (nx*ny,variable)

basename = os.path.basename(filename)
basename = os.path.splitext(basename)[0]

for t in range(0,nt):
  st   = str(t+1)
  st   = st.zfill(td)
  name = basename + "_" + st + ".vtk"
  print("Processing time step t=%s..." % st)
  print("Writing output file '%s'..."  % name)
  with open(name, "w") as f:
    print(header, file=f)

    # Coordinates
    for iy in range(ny):
      for ix in range(nx):
        x = lons[ix]
        y = lats[iy]
        z = 0.0
        print(x,y,z, file=f)

    print(scalars, file=f)

    # Data
    for iy in range(ny):
      for ix in range(nx):
        print(dataSet.variables[variable][t][iy][ix], file=f)

dataSet.close()
